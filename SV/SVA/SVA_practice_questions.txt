SVA Practice questions:
a)signal x only asserted for 3 cycles
sequence Justhree(x) $rose(x) ##1 x[*2] ## $fell(x)

b)no grant if there wasn't a request in a previous cycle
a1:assert property(@(posedge clk) disable iff rst
                        ((|gnt) || !$past(|req))); 

//Go-to non-consecutive exact repetition
c)after start & upon each request req, starting from the 2nd and ending with the 5th cycle, enable is asserted
p1:assert property(start ##1 req[->2:5] ##1 enable); //enable immediately occurs following the last occurrence of req

//non-consecutive repetition operator
a ##1 b[=1:3] ##1 c
Satisfied by trace:
a !b b !b b !b !b b !b !b !b !b c
(b doesn't need to be true in the clock cycle before c is true)

//are the following same?
a) write ##1 done |=> read
b) write |=> done ##1 read
Not same. Looks very same but very different. The antecedent for a) is dependent on (write ##1 done) sequence to be true whereas
in b) write is only considered on the antecedent side as a trigger which is clearly different from b).

TODOs: More practice questions for tom (4/15):
b)ref:- https://reverent-northcutt-8163cd.netlify.app/blog/common_assertion/
f)Refer for [*],[+] operator usage:- https://systemverilog.us/vf/goto_conseq.pdf
g)write a systemverilog assertion such that a variable once asserted shouldn't be asserted again. by asserted again, it means if it was high it should remain high & if low remain low.
Ans:- property sig_locks_after_first_value;
  @(posedge clk)
  $rose(sig === 1'b0 || sig === 1'b1) |-> $stable(sig)[*];
endproperty
assert property (sig_locks_after_first_value);
h)solve the ones from tom's assignments of abv

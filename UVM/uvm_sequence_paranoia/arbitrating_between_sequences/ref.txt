Parallel multiple sequences on same sequencer:
What happens when parallel multiple sequences are started on a single sequencer?
-->sequencer decides based on the arbitration mechanism which sequence gets priority to send seq_item to driver.

**sequencers have built-in multiple sequence arbitration algorithms
1)seq.start(sqr, this, priority);
2)SEQ_ARB_FIFO arb policy is the default arb policy set by the sqr in uvm which means whichever seq calls start_item() first gets sent first, whichever seq calls start_item() second, 
goes next and so on....... (priority arg is ignored here)
Command                         arbitration                                         priority
UVM_SEQ_ARB_FIFO            seq_items are ordered as FIFO - default                     ignored
UVM_SEQ_ARB_RANDOM          seq_items are ordered randomly                              ignored
UVM_SEQ_ARB_WEIGHTED        seq_items are ordered based on priority                     weighted priority (default prio - 100, prio>100 => high priority, prio<100 => low priority)
UVM_SEQ_ARB_STRICT_FIFO     seq_items are ordered as FIFO                               honored
UVM_SEQ_ARB_STRICT_RANDOM   sequences are ordered randomly                              honored
UVM_SEQ_ARB_USER            sequences are ordered by a user-specified arb algorithms    user-defined

***How to set sqr arbitration policy in vseq?
-->In the virtual task body(), one can set the sqr arb policy using the built-in set_arbitration() method:
sqr.set_arbitration(UVM_SEQ_ARB_RANDOM)

***How to set the sequence priority????
-->seq_items generated by one sequence can be given a higher or lower priority than those from another sequence
1)priority is specified as a weight factor - the default weight is 100
2)the priority affects certain sequencer arbitration algorithms

-->> There are two ways to set a sequence's priority
a)As an argument to the sequence start() method (the example below)
b)call set_priority(N) in the sequence

class dual_ahb_vseq extends uvm_sequence;
  //The sqr decides which seq_item to pass to the driver
  uvm_sequencer #(ahb_item) sqr; // this will be assigned the handle to agt sqr either via cfg object/init_start()
  
  ahb_sequence ahb_seq1;
  ahb_sequence ahb_seq2;
  
  virtual task body();
    //set the arb policy for the sqr to use (default if not set - UVM_SEQ_ARB_FIFO)
    sqr.set_arbitration(UVM_SEQ_ARB_WEIGHTED);
    ahb_seq1 = ahb_sequence::type_id::create("ahb_seq1', this);
    ahb_seq2 = ahb_sequence::type_id::create("ahb_seq2', this);
    //Based on priority weights on seq1 & seq2, seq1 seq_items are picked more often than seq2 seq_items
    fork
      ahb_seq1.start(sqr, this, 200);
      ahb_seq2.start(sqr, this, 100);
    join
  endtask
endclass